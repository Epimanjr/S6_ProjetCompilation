/*
 * Analyseur syntaxique
 *
 */ 
 
package fr.ul.miage.projet.generated;
import java_cup.runtime.Symbol;

/* Contrôle des erreurs de syntaxe : surcharge */
parser code {:
	public void syntax_error(Symbol cur_token){}
	public void unrecovered_syntax_error(Symbol cur_token) throws Exception{
		throw new Exception("Erreur");
	}
:}

/* Action code */
action code {:
	String Scope=0; /* 0 correspond à global*/
	int rang_loc=0;
	int rang_arg=0;
:}

/* La grammaire */

terminal VRAI, FAUX, NOMBRE, IDF;		/* Atomes */
terminal INT, VOID;						/* Types */
terminal EGAL, VIRGULE, POINTVIRGULE,PV,AO,AF,PO,PF;	/* Ponctuation */
terminal PG, PD, AG, AD;
terminal PLUS, MOINS;					/* Opérateurs */
terminal FOIS, DIVISE;
terminal PPQ, PPE, PGQ, PGE;
terminal IF, ELSE, WHILE;				/* Noms réservés */
terminal NOT;
terminal RET;

non terminal prog;
non terminal seq_fonctions, fonction, bloc,suite_seq_fonctions;
non terminal seq_instructions, instruction,suite_seq_instructions;
non terminal declaration, suite_declaration, affectation;
non terminal condition, iteration, expr_booleen, booleen;
non terminal appel_fonction, param_appel, suite_param_appel, parametres, suite_parametres, argument, retour;
non terminal expression, facteur, atome, type,valeur;
non terminal op_secondaire, op_prioritaire, op_booleen;
non terminal definition_loc,liste_definition_loc,definition_fonction,definition_arg,liste_definition_arg;

start with prog;

/*------debut-------*/

/* NB: une séquence est une suite de quelque chose */

prog ::= seq_instructions:si seq_fonctions:sf		{:	TableDesSymboles tds = new TableDesSymboles();
														Arbre arbre = new Arbre();
														Noeud n = Noeud.PROG;
														n.ajouterFG(si);
														n.ajouterFD(sf);
														arbre.setRacine(n);
														RESULT = n;
													:}
		;
		
seq_fonctions ::= fonction:f suite_seq_fonctions:ssf		{:	Noeud n = Noeud.SEQFONCT
																n.ajouterFD(f);
																RESULT = ssf;
															:}
			| /* VIDE */
			;
			
suite_seq_fonctions ::= fonction:f suite_seq_fonctions:ssf		{:	this.ajouterFD(f);
																	RESULT = ssf;
																:}
					| /* VIDE */
					;
			
fonction ::= type:t IDF:idf PG parametres:param PD bloc:bc			{:	Noeud n = Noeud.FONCT;
																		n.ajouterFG(t);
																		n.ajouterFD(idf);
																		n.ajouterFD(param);
																		n.ajouterFD(bc);
																		RESULT = n;
																	:}
		| IDF:idf PG parametres:param PD bloc:bc					{:	Noeud n = Noeud.FONCT;
																		n.ajouterFG(idf);
																		n.ajouterFD(param);
																		n.ajouterFD(bc);
																		RESULT = n;
																	:}
		;
			
bloc ::= AG AD							{: RESULT = Noeud.BLOC; :}
		| AG seq_instructions:si AD		{:	Noeud n = Noeud.BLOC
											n.ajouterFD(si);
										:}
		;

seq_instructions ::= instruction:i suite_seq_instructions:ssi		{:	Noeud n = Noeud.SEQINSTR
																		n.ajouterFD(i);
																		RESULT = ssi;
																	:}
				| /* VIDE */
				;
				
suite_seq_instructions ::= instruction:i suite_seq_instructions:ssi	{:	this.ajouterFD(i);
																		RESULT = ssi;
																	:}
						| /* VIDE */
						;
		
instruction ::= declaration:dec POINTVIRGULE		{:	Noeud n = Noeud.INSTR;
														n.ajouterFD(dec);
														RESULT = n;
													:}
			| affectation:aff POINTVIRGULE			{:	Noeud n = Noeud.INSTR;
														n.ajouterFD(aff);
														RESULT = n;
													:}
			| condition:cond						{:	Noeud n = Noeud.INSTR;
														n.ajouterFD(cond);
														RESULT = n;
													:}
			| iteration:it							{:	Noeud n = Noeud.INSTR;
														n.ajouterFD(it);
														RESULT = n;
													:}
			| appel_fonction:apf POINTVIRGULE		{:	Noeud n = Noeud.INSTR;
														n.ajouterFD(apf);
														RESULT = n;
													:}
			| retour:ret POINTVIRGULE				{:	Noeud n = Noeud.INSTR;
														n.ajouterFD(ret);
														RESULT = n;
													:}
			;		

declaration ::= type:t IDF:idf suite_declaration:sdec					{:	Noeud n = Noeud.DECLARATION;		/* declaration et suite_declaration � v�rifier */
																			n.ajouterFG(t);
																			n.ajouterFD(idf);
																			RESULT = sdec;
																		:}
			| type:t IDF:idf suite_declaration:sdec EGAL expression:e	{:	Noeud n = Noeud.DECLARATION;
																			Noeud op = Noeud.EGAL;
																			n.ajouterFG(op);
																			op.ajouterFG(t);
																			op.ajouterFD(idf);
																			RESULT = sdec;
																			op.ajouterFD(e);
																		:}
			;

suite_declaration ::= VIRGULE IDF:idf suite_declaration:sdec	{:	this.ajouterFD(idf);
																	RESULT = sdec;
																:}
					| /* VIDE */
					;
				
affectation ::= IDF EGAL expression:e		{:	Noeud n = Noeud.ASSIGN;
												Noeud op = Noeud.EGAL;
												n.ajouterFG(op);
												op.ajouterFG(idf);
												op.ajouterFD(e);
												RESULT = n;
											:}
			;
			
condition ::= IF PG expr_booleen:eb PD bloc:bc1					{:	Noeud n = Noeud.IF;
																	n.ajouterFG(eb);
																	n.ajouterFD(bc1);
																	RESULT = n;
																:}
			| IF PG expr_booleen:eb PD bloc:bc1 ELSE bloc:bc2	{:	Noeud n = Noeud.IF;
																	n.ajouterFils(eb);
																	n.ajouterFils(bc1);
																	n.ajouterFils(bc2);
																	RESULT = n;
																:}
			;

iteration ::= WHILE PG expr_booleen:eb PD bloc:bc		{:	Noeud n = Noeud.WHILE;
															n.ajouterFG(eb);
															n.ajouterFD(bc);
															RESULT = n;
														:}
			;
			
expr_booleen ::= booleen:b									{:	Noeud n = Noeud.BOOL;
																n.ajouterFG(b);
																RESULT = n; :}
			| NOT expr_booleen:eb							{:	Noeud n = Noeud.NOT;
																n.ajouterFils(eb);
																RESULT = n;
															:}
			| expression:e1 op_booleen:opb expression:e2	{:	Noeud n = Noeud(opb);
																n.ajouterFG(e1);
																n.ajouterFD(e2);
																RESULT = n;
															:}
			;

booleen ::= VRAI	{: RESULT = Noeud.VRAI; :}
		| FAUX		{: RESULT = Noeud.FAUX; :}
		;
		
appel_fonction ::= IDF:idf PG param_appel:paap PD		{:	Noeud n = Noeud.APPEL;
															n.ajouterFG(idf);
															RESULT = paap;
														:}
				;

param_appel ::= expression:e suite_param_appel:spaap		{:	this.ajouterFD(e);
																RESULT = spaap;
															:}
			| /* VIDE */
			;
			
suite_param_appel ::= VIRGULE expression:e suite_param_appel:spaap		{:	this.ajouterFD(e);
																			RESULT = spaap;
																		:}
					| /* VIDE */
					;
					
parametres ::= argument:arg suite_parametres:spa		{:	Noeud n = Noeud.PARAM;
															n.ajouterFG(arg);
															RESULT = spa;
														:}
			| /* VIDE */
			;
			
suite_parametres ::= VIRGULE argument:arg suite_parametres:spa		{:	this.ajouterFD(arg);
																		RESULT = spa;
																	:}
				| /* VIDE */
				;
				
argument ::= type:t IDF:idf		{:	Noeud n = Noeud.ARGUMENT;
									n.ajouterFG(t);
									n.ajouterFD(idf);
									RESULT = n;
									TableDesSymboles.insertion(idf,Scope,t,v,rang_arg++);
								:}
		| /* VIDE */
		;
			
retour ::= RET expression:e		{:	Noeud n = Noeud.RET;
									n.ajouterFG(e);
									RESULT = n;
								:}
		| RET					{: RESULT = Noeud.RET; :}
		;
		
expression ::= expression:e op_secondaire:op2 facteur:f	{:  Noeud n = op2;
															n.ajouterFG(e);
															n.ajouterFD(f);
															RESULT = n;
														:}
			| facteur:f									{: RESULT = f; :}
			;
			
facteur ::= facteur:f op_prioritaire:op1 atome:a	{:  Noeud n = op1;
														n.ajouterFG(f);
														n.ajouterFD(a);
														RESULT = n;
													:}
		| atome:a									{: RESULT = a; :}
		| appel_fonction:af							{: RESULT = af; :}
		;
		
atome ::= NOMBRE:nb					{:	Noeud n = Noeud.NOMBRE;
										n.ajouterFG(nb);
										RESULT = n;
									:}
		| IDF:idf					{:	Noeud n = Noeud.IDF;
										n.ajouterFG(tds.rechercher(idf));
										RESULT = n;
									:}
		| PG expression:e PD		{: RESULT = e; :};

type ::= INT		{: RESULT = Noeud.INT; :}
	   | VOID		{: RESULT = Noeud.VOID; :}
	   ;
	   
op_secondaire ::= PLUS		{: RESULT = Noeud.PLUS; :}
				| MOINS		{: RESULT = Noeud.MOINS; :}
				;
			
op_prioritaire ::= FOIS		{: RESULT = Noeud.FOIS; :}
				| DIVISE	{: RESULT = Noeud.DIVISE; :}
				;
			
op_booleen ::= PPQ	{: RESULT = Noeud.PPQ; :}
			| PPE	{: RESULT = Noeud.PPE; :}
			| PGQ	{: RESULT = Noeud.PGQ; :}
			| PGE	{: RESULT = Noeud.PGE; :}
			;
			
/* insertion dans la table des symbole*/
definition_loc::= type:t IDF:idf 
			{:TableDesSymboles.insertion(idf,Scope,t,"null",rang_loc++);:};
liste_definition_loc::=definition_loc liste_definition_loc |;

definition_arg::= type:t IDF:idf 
			{:TableDesSymboles.insertion(idf,Scope,t,"null",rang_loc++);:};
liste_definition_arg::=definition_arg liste_definition_arg |;
			
definition_fonction::=type IDF:idf {:TableDesSymboles.insertion(idf,0);:}
					PO argument PF AO liste_definition_loc{:TableDesSymboles.setArg_Loc(idf);:}
					seq_instructions AF;
 
/*------fin--------*/

