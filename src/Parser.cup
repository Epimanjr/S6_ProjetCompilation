/*
 * Analyseur syntaxique
 *
 */ 
package fr.ul.miage.projet.generated;
import java_cup.runtime.Symbol;
import fr.ul.miage.projet.*;
import java.util.*;

/* contrÃ´le des erreurs de syntaxe : surcharge */
parser code {:
	public void syntax_error(Symbol cur_token){}
	public void unrecovered_syntax_error(Symbol cur_token) throws Exception{
		throw new Exception("Erreur");
	}
:}

/*action code*/
action code {:
	TableDesSymboles tds = new TableDesSymboles();
:}

/* la grammaire */

terminal String IDF;
terminal EGAL;
terminal VIRGULE;
terminal POINTVIRGULE;
terminal String NOMBRE;
terminal INT;
terminal VOID;
terminal PG;
terminal PD;
terminal AG;
terminal AD;
terminal PLUS;
terminal MOINS;
terminal FOIS;
terminal DIVISE;
terminal RET;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal PPQ;
terminal PPE;
terminal PGQ;
terminal PGE;
terminal VRAI;
terminal FAUX;

non terminal x;
non terminal prog;
non terminal type;
non terminal datas;
non terminal data;
non terminal contenudata;
non terminal declaration;
non terminal codes;
non terminal fonction;
non terminal ArrayList<Noeud> parametres;
non terminal ArrayList<Noeud> suiteParametres;
non terminal ArrayList<Noeud> parametresCall;
non terminal ArrayList<Noeud> suiteParametresCall;
non terminal Noeud argument;
non terminal block;
non terminal contenuBlock;
non terminal instruction;
non terminal affectation;
non terminal Noeud expression;
non terminal Noeud facteur;
non terminal Noeud exprBooleen;
non terminal Noeud valeur;
non terminal Noeud call;
non terminal instrReturn;
non terminal String op_prioritaire;
non terminal String op_secondaire;
non terminal String operateurBooleen;
non terminal condition;
non terminal booleen;
non terminal iteration;


start with x;

/*------debut-------*/


x ::= prog
		;

prog ::= datas:ds codes:c		{:	Noeud n = new Noeud(Noeud.PROG);		/* On crée un noeud de départ */
									Noeud datas = new Noeud(Noeud.DATAS);	/* On crée un noeud pour les datas et un noeud pour les codes */
									Noeud codes = new Noeud(Noeud.CODES);
									n.ajouterFG(datas);
									n.ajouterFG(codes);
									datas.ajouterNoeud(ds);					/* Les datas seront les fils du noeud DATAS et les codes ceux du noeud CODE */
									codes.ajouterNoeud(c);
									RESULT = n; :} 
		;

datas ::= datas:ds data:d		{:	ds.add(0,d);
									RESULT = ds; :}
		| /* VIDE */			{: RESULT = new ArrayList<Noeud>(); :}
		;

data ::= type contenudata POINTVIRGULE
		;

contenudata ::= declaration | contenudata VIRGULE declaration
			;

declaration ::= IDF | IDF EGAL NOMBRE
			;
		
codes ::= codes:c fonction:f		{:	c.add(0,f);
										RESULT = c; :}
		| /* VIDE */				{: RESULT = new ArrayList<Noeud>(); :}
		; 
	
fonction ::= type:t IDF:idf PG parametres:p PD block:b		{:	Noeud n = new Noeud(Noeud.FONCTION, tds.rechercher(idf));
																n.ajouterFG(t);
																n.ajouterFD(p);
																n.ajouterFD(b);
																RESULT = n; :}
			| IDF:idf PG parametres:p PD block:b			{:	Noeud n = new Noeud(Noeud.FONCTION, tds.rechercher(idf));
																n.ajouterFD(p);
																n.ajouterFD(b);
																RESULT = n; :}
			;


block ::= AG contenuBlock:cb AD		{:	Noeud n = new Noeud(Noeud.BLOC);
										n.ajouterNoeud(cb);
										RESULT = n; :} 
		;

contenuBlock ::= contenuBlock:cb instruction:i	{:	cb.add(0,i);
													RESULT = cb; :}
				| /* VIDE */ 					{: RESULT = new ArrayList<Noeud>(); :}
				;

instruction ::= affectation
			| data
			| instrReturn
			| call
			| condition
			| iteration
			;

condition ::= IF PG booleen:bool PD block:b1				{:	Noeud n = new Noeud(Noeud.IF);
																n.ajouterFG(bool);
																n.ajouterFD(b1);
																RESULT = n; :}
			| IF PG booleen:bool PD block:b1 ELSE block:b2	{:	Noeud n = new Noeud(Noeud.IF);
																n.ajouterFG(bool);
																n.ajouterFD(b1);
																n.ajouterFD(b2);
																RESULT = n; :}
			;

iteration ::= WHILE PG booleen:bool PD block:b	{:	Noeud n = new Noeud(Noeud.WHILE);
													n.ajouterFG(bool);
													n.ajouterFD(b);
													RESULT = n; :}
			;

booleen ::= VRAI			{: RESULT = Noeud.VRAI; :}
		  | FAUX			{: RESULT = Noeud.FAUX; :}
		  | exprBooleen		{: RESULT = e; :}
		  ;

exprBooleen ::= valeur:v operateurBooleen:opb exprBooleen:e	{: Noeud n = new Noeud(opb);
														   	   n.ajouterFG(v);
														   	   n.ajouterFD(e);
														   	   RESULT = n; :}
			  | valeur:v									{: RESULT = v; :}
			  ;

instrReturn ::= RET expression POINTVIRGULE
			| RET POINTVIRGULE
			;

affectation ::= IDF:idf EGAL expression:e POINTVIRGULE	{: Noeud n = new Noeud(Noeud.AFFECTATION);
														   Noeud nIDF = new Noeud(Noeud.IDF, tds.rechercher(idf));
														   n.ajouterFG(nIDF);
														   n.ajouterFD(e);
														   RESULT = n; :}
			;

expression ::= expression:e op_secondaire:op2 facteur:f	{: Noeud n = new Noeud(op2);
														   n.ajouterFG(e);
														   n.ajouterFD(f);
														   RESULT = n; :}
			| facteur:f									{: RESULT = f; :}
			;
			
facteur ::= facteur:f op_prioritaire:op1 valeur:v		{: Noeud n = new Noeud(op1);
														   n.ajouterFG(f);
														   n.ajouterFD(v);
														   RESULT = n; :}
		| valeur:v										{: RESULT = v; :}
		;
		
valeur ::= NOMBRE:nb									{: RESULT = new Noeud(Noeud.NOMBRE, nb); :}
		| IDF:idf										{: RESULT = new Noeud(Noeud.IDF, tds.rechercher(idf)); :}
		| PG expression:e PD							{: RESULT = e; :}
		| call:c										{: RESULT = c; :}
		;

call ::= IDF:idf PG parametresCall:pc PD				{: Noeud n = new Noeud(Noeud.CALL, tds.rechercher(idf));
														   n.ajouterNoeud(pc);
														   RESULT = n; :} 
		;

parametres ::= argument:a suiteParametres:sp			{: sp.add(0,a);
														   RESULT = sp; :}
			| /* VIDE */								{: RESULT = new ArrayList<Noeud>(); :}
			;
			
suiteParametres ::= VIRGULE argument:a suiteParametres:sp {: sp.add(0,a);
															 RESULT = sp; :}
				  | /* VIDE */							  {: RESULT = new ArrayList<Noeud>(); :}
			;

parametresCall ::= expression:e suiteParametresCall:spc {: spc.add(0,e);
														   RESULT = spc; :}
				 | /* VIDE */							{: RESULT = new ArrayList<Noeud>(); :}
				 ;

suiteParametresCall ::= VIRGULE expression:e suiteParametresCall:spc {: spc.add(0,e);
														   				RESULT = spc; :}
				 	  | /* VIDE */						{: RESULT = new ArrayList<Noeud>(); :}
					  ;

argument ::= type IDF 
			| call
			;
			
type ::= INT
	   | VOID
	   ;

op_secondaire ::= PLUS									{: RESULT = Noeud.PLUS; :}
				| MOINS									{: RESULT = Noeud.MOINS; :}
				;
			
op_prioritaire ::= FOIS									{: RESULT = Noeud.FOIS; :}
				| DIVISE								{: RESULT = Noeud.DIVISE; :}
				;

operateurBooleen ::= PPQ								{: RESULT = Noeud.PPQ; :}
				   | PPE								{: RESULT = Noeud.PPE; :}
				   | PGQ								{: RESULT = Noeud.PGQ; :}
				   | PGE								{: RESULT = Noeud.PGE; :}
				   ;

/*------fin--------*/

