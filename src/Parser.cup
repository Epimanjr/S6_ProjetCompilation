/*
 * Analyseur syntaxique
 *
 */ 
package fr.ul.miage.projet.generated;
import java_cup.runtime.Symbol;
import fr.ul.miage.projet.*;
import java.util.*;

/* contr√¥le des erreurs de syntaxe : surcharge */
parser code {:
	public void syntax_error(Symbol cur_token){}
	public void unrecovered_syntax_error(Symbol cur_token) throws Exception{
		throw new Exception("Erreur");
	}
:}

/*action code*/
action code {:
	TableDesSymboles tds = new TableDesSymboles();
:}

/* la grammaire */

terminal String IDF;
terminal EGAL;
terminal VIRGULE;
terminal POINTVIRGULE;
terminal String NOMBRE;
terminal INT;
terminal VOID;
terminal PG;
terminal PD;
terminal AG;
terminal AD;
terminal PLUS;
terminal MOINS;
terminal FOIS;
terminal DIVISE;
terminal RET;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal PPQ;
terminal PPE;
terminal PGQ;
terminal PGE;
terminal VRAI;
terminal FAUX;

non terminal x;
non terminal prog;
non terminal type;
non terminal datas;
non terminal data;
non terminal contenudata;
non terminal declaration;
non terminal codes;
non terminal fonction;
non terminal List<Noeud> parametres;
non terminal List<Noeud> parametresCall;
non terminal argument;
non terminal block;
non terminal contenuBlock;
non terminal instruction;
non terminal affectation;
non terminal Noeud expression;
non terminal Noeud exprBooleen;
non terminal Noeud valeur;
non terminal Noeud call;
non terminal instrReturn;
non terminal String operateur;
non terminal String operateurBooleen;
non terminal condition;
non terminal booleen;
non terminal iteration;


start with x;

/*------debut-------*/


x ::= prog
		;

prog ::= datas | datas codes | codes
		;

datas ::= data | datas data
		;

data ::= type contenudata POINTVIRGULE
		;

contenudata ::= declaration | contenudata VIRGULE declaration
			;

declaration ::= IDF | IDF EGAL NOMBRE
			;
		
codes ::= fonction | codes fonction
		; 
	
fonction ::= type IDF PG parametres PD block | IDF PG parametres PD block
			;


block ::= AG contenuBlock AD
		| AG AD
		;

contenuBlock ::= instruction 
				| contenuBlock instruction
				;

instruction ::= affectation 
			| data
			| instrReturn
			| call
			| condition
			| iteration
			;

condition ::= IF PG booleen PD block
			| IF PG booleen PD block ELSE block
			;

iteration ::= WHILE PG booleen PD block
			;

booleen ::= VRAI
			| FAUX
			| exprBooleen
			;

exprBooleen ::= valeur 
			| valeur operateurBooleen exprBooleen
			;

instrReturn ::= RET expression POINTVIRGULE
			| RET POINTVIRGULE
			;

affectation ::= IDF EGAL expression POINTVIRGULE
			;

valeur ::= NOMBRE:c		{: RESULT = new Noeud(Noeud.CONST,c); :}	
		| IDF
		| call
		;

call ::= IDF PG parametresCall PD
		;

expression ::= valeur:v																{:  RESULT = v;
																					:}
			| valeur:v operateur:o expression:e										{:  Noeud n = new Noeud(o);
																						n.ajouterFG(v);
																						n.ajouterFD(e);
																						RESULT = n;
																					:}
			| PG valeur:v operateur:o expression:e PD								{:  Noeud n = new Noeud(o);
																						n.ajouterFG(v);
																						n.ajouterFD(e);
																						RESULT = n;
																					:}
			| PG valeur:v operateur:o expression:e PD operateur:o2 expression:e2	{:  Noeud n = new Noeud(o);
																						n.ajouterFG(v);
																						n.ajouterFD(e);
																						Noeud n2 = new Noeud(o2);
																						n2.ajouterFG(n);
																						n2.ajouterFD(e2);
																						RESULT = n2;
																					:}
			;

parametres ::= argument 
			| parametres VIRGULE argument
			| call
			;

parametresCall ::= expression 
				| parametresCall VIRGULE expression
				| /* EMPTY */
				;

argument ::= type IDF 
			| /* EMPTY */
			;
			
type ::= INT
	   | VOID
	   ;

operateur ::= PLUS			{: RESULT = Noeud.PLUS; :}
			| MOINS			{: RESULT = Noeud.MOINS; :}
			| FOIS			{: RESULT = Noeud.FOIS; :}
			| DIVISE		{: RESULT = Noeud.DIVISE; :}
			;

operateurBooleen ::= PPQ	{: RESULT = Noeud.PPQ; :}
				   | PPE	{: RESULT = Noeud.PPE; :}
				   | PGQ	{: RESULT = Noeud.PGQ; :}
				   | PGE	{: RESULT = Noeud.PGE; :}
				   ;

/*------fin--------*/

