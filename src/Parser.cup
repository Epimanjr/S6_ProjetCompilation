/*
 * Analyseur syntaxique
 *
 */ 
package fr.ul.miage.projet.generated;
import java_cup.runtime.Symbol;
import fr.ul.miage.projet.*;
import java.util.*;

/* contr√¥le des erreurs de syntaxe : surcharge */
parser code {:
	public void syntax_error(Symbol cur_token){}
	public void unrecovered_syntax_error(Symbol cur_token) throws Exception{
		throw new Exception("Erreur");
	}
:}

/*action code*/
action code {:
	TableDesSymboles tds = new TableDesSymboles();
:}

/* la grammaire */

terminal String IDF;
terminal EGAL;
terminal VIRGULE;
terminal POINTVIRGULE;
terminal String NOMBRE;
terminal INT;
terminal VOID;
terminal PG;
terminal PD;
terminal AG;
terminal AD;
terminal PLUS;
terminal MOINS;
terminal FOIS;
terminal DIVISE;
terminal RET;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal PPQ;
terminal PPE;
terminal PGQ;
terminal PGE;
terminal VRAI;
terminal FAUX;

non terminal x;
non terminal prog;
non terminal type;
non terminal datas;
non terminal data;
non terminal contenudata;
non terminal declaration;
non terminal codes;
non terminal fonction;
non terminal List<Noeud> parametres;
non terminal List<Noeud> parametresCall;
non terminal argument;
non terminal block;
non terminal contenuBlock;
non terminal instruction;
non terminal affectation;
non terminal Noeud expression;
non terminal Noeud facteur;
non terminal Noeud exprBooleen;
non terminal Noeud valeur;
non terminal Noeud call;
non terminal instrReturn;
non terminal String op_prioritaire;
non terminal String op_secondaire;
non terminal String operateurBooleen;
non terminal condition;
non terminal booleen;
non terminal iteration;


start with x;

/*------debut-------*/


x ::= prog
		;

prog ::= datas | datas codes | codes
		;

datas ::= data | datas data
		;

data ::= type contenudata POINTVIRGULE
		;

contenudata ::= declaration | contenudata VIRGULE declaration
			;

declaration ::= IDF | IDF EGAL NOMBRE
			;
		
codes ::= fonction | codes fonction
		; 
	
fonction ::= type IDF PG parametres PD block | IDF PG parametres PD block
			;


block ::= AG contenuBlock AD
		| AG AD
		;

contenuBlock ::= instruction 
				| contenuBlock instruction
				;

instruction ::= affectation 
			| data
			| instrReturn
			| call
			| condition
			| iteration
			;

condition ::= IF PG booleen PD block
			| IF PG booleen PD block ELSE block
			;

iteration ::= WHILE PG booleen PD block
			;

booleen ::= VRAI
			| FAUX
			| exprBooleen
			;

exprBooleen ::= valeur 
			| valeur operateurBooleen exprBooleen
			;

instrReturn ::= RET expression POINTVIRGULE
			| RET POINTVIRGULE
			;

affectation ::= IDF EGAL expression POINTVIRGULE
			;

expression ::= expression:e op_secondaire:op2 facteur:f	{:  Noeud n = new Noeud(op2);
															n.ajouterFG(e);
															n.ajouterFD(f);
															RESULT = n;
														:}
			| facteur:f									{: RESULT = f; :}
			;
			
facteur ::= facteur:f op_prioritaire:op1 valeur:v		{:  Noeud n = new Noeud(op1);
														n.ajouterFG(f);
														n.ajouterFD(v);
														RESULT = n;
														:}
		| valeur:v										{: RESULT = v; :}
		;
		
valeur ::= NOMBRE:nb									{: RESULT = new Noeud(Noeud.NOMBRE, nb); :}
		| IDF:idf										{: RESULT = new Noeud(Noeud.IDF, tds.rechercher(idf)); :}
		| PG expression:e PD							{: RESULT = e; :}
		| call:c										{: RESULT = c; :}
		;

call ::= IDF PG parametresCall PD
		;

parametres ::= argument 
			| parametres VIRGULE argument
			| call
			;

parametresCall ::= expression 
				| parametresCall VIRGULE expression
				| /* EMPTY */
				;

argument ::= type IDF 
			| /* EMPTY */
			;
			
type ::= INT
	   | VOID
	   ;

op_secondaire ::= PLUS									{: RESULT = Noeud.PLUS; :}
				| MOINS									{: RESULT = Noeud.MOINS; :}
				;
			
op_prioritaire ::= FOIS									{: RESULT = Noeud.FOIS; :}
				| DIVISE								{: RESULT = Noeud.DIVISE; :}
				;

operateurBooleen ::= PPQ								{: RESULT = Noeud.PPQ; :}
				   | PPE								{: RESULT = Noeud.PPE; :}
				   | PGQ								{: RESULT = Noeud.PGQ; :}
				   | PGE								{: RESULT = Noeud.PGE; :}
				   ;

/*------fin--------*/

